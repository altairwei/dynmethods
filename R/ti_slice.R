######################################### DO NOT EDIT! #########################################
#### This file is automatically generated from data-raw/2-generate_r_code_from_containers.R ####
################################################################################################

#' @title Inferring a trajectory inference using SLICE
#' 
#' @description
#' Will generate a trajectory using [SLICE](https://doi.org/10.1093/nar/gkw1278).
#' 
#' This method was wrapped inside a
#' [container](https://github.com/dynverse/ti_slice).
#' The original code of this method is available
#' [here](https://research.cchmc.org/pbge/slice.html).
#' 
#' @references Guo, M., Bao, E.L., Wagner, M., Whitsett, J.A., Xu, Y., 2016.
#' SLICE: determining cell differentiation and lineage based on single cell
#' entropy. Nucleic Acids Research gkw1278.
#' 
#' @param lm.method discrete; Select "clustering" based or "graph" based method to
#' infer lineage model (default: `"clustering"`; values: {`"clustering"`,
#' `"graph"`})
#' @param model.type discrete; The type of models that will be infered: "tree" -
#' directed minimum spanning tree based, "graph" - directed graph based (default:
#' `"tree"`; values: {`"tree"`, `"graph"`})
#' @param ss.method discrete; The method for defining core cell set for stable
#' state detection: all - all the cells in a cluster constitute the core cell set;
#' top - cells with scEntropy lower than the ss.threshold quantile of all the
#' values in a cluster constitute the core cell set; pcst - cells with scEntropy
#' lower than the ss.threshold quantile of all the values in a cluster constitute
#' the prize nodes, linear prize-collecting steiner tree algorithm is used to
#' approximate an optimal subnetwork, the cells in the subnetwork constitute the
#' core cell set. Stable states are defined as the centroids of the core cell
#' sets. (default: `"all"`; values: {`"all"`, `"top"`, `"pcst"`})
#' @param ss.threshold numeric; The threshold used when ss.method is "top" or
#' "pcst". Default: 0.25. (default: `0.25`; range: from `0` to `1`)
#' @param community.method discrete; The method for network community detection.
#' Most of the community detection methods implemented in the igraph package are
#' supported, including "fast_greedy", "edge_betweenness", "label_prop",
#' "leading_eigen","louvain","spinglass", "walktrap". If this parameter is set to
#' "auto", the algorithm will perform all the community detection methods and
#' select the one that generates the communities with best modularity. Only take
#' effect when lm.method is "graph" (default: `"louvain"`; values:
#' {`"fast_greedy"`, `"edge_betweenness"`, `"label_prop"`, `"leading_eigen"`,
#' `"louvain"`, `"spinglass"`, `"walktrap"`, `"auto"`})
#' @param cluster.method discrete; Use "kmeans" or "pam" to divide cells into
#' clusters. Only take effect when lm.method is "clustering" (default: `"kmeans"`;
#' values: {`"kmeans"`, `"pam"`})
#' @param k integer; The number of cell clusters. If NULL, Gap statistic will be
#' used to determine an optimal k. (default: `0L`; range: from `0L` to `20L`)
#' @param k.max integer; The "k.max" parameter of cluster::clusGap(); used when k
#' is NULL. (default: `10L`; range: from `3L` to `20L`)
#' @param B integer; The "B" parameter of cluster::clusGap(); used when k is NULL
#' (default: `100L`; range: from `3L` to `500L`)
#' @param k.opt.method discrete; The "method" parameter of cluster::maxSE(); used
#' when k is NULL (default: `"firstmax"`; values: {`"firstmax"`, `"globalmax"`,
#' `"Tibs2001SEmax"`, `"firstSEmax"`, `"globalSEmax"`})
#' @inheritParams dynwrap::create_ti_method_container
#' 
#' @return A TI method wrapper to be used together with
#' \code{\link[dynwrap:infer_trajectories]{infer_trajectory}}
#' @export
ti_slice <- function(
    lm.method = "clustering",
    model.type = "tree",
    ss.method = "all",
    ss.threshold = 0.25,
    community.method = "louvain",
    cluster.method = "kmeans",
    k = 0L,
    k.max = 10L,
    B = 100L,
    k.opt.method = "firstmax"
) {
  create_ti_method_container(
    container_id = "dynverse/ti_slice",
    version = dynmethods::method_versions[["dynverse/ti_slice"]],
  )(
    lm.method = lm.method,
    model.type = model.type,
    ss.method = ss.method,
    ss.threshold = ss.threshold,
    community.method = community.method,
    cluster.method = cluster.method,
    k = k,
    k.max = k.max,
    B = B,
    k.opt.method = k.opt.method
  )
}

