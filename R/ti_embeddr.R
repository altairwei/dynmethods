######################################### DO NOT EDIT! #########################################
#### This file is automatically generated from data-raw/2-generate_r_code_from_containers.R ####
################################################################################################

#' @title Inferring a trajectory inference using Embeddr
#' 
#' @description
#' Will generate a trajectory using [Embeddr](https://doi.org/10.1101/027219).
#' 
#' This method was wrapped inside a
#' [container](https://github.com/dynverse/ti_embeddr).
#' The original code of this method is available
#' [here](https://github.com/kieranrcampbell/embeddr).
#' 
#' @references Campbell, K., Ponting, C.P., Webber, C., 2015. Laplacian eigenmaps
#' and principal curves for high resolution pseudotemporal ordering of single-cell
#' RNA-seq profiles.
#' 
#' @param ndim integer; Dimension of the embedded space, default is 2 (default:
#' `2L`; range: from `2L` to `10L`)
#' @param kernel discrete; The choice of kernel. 'nn' will give nearest
#' neighbours, 'dist' gives minimum distance and'heat' gives a heat kernel.
#' Discussed in detail in 'Laplacian Eigenmaps and Spectral Techniques for
#' Embedding and Clustering',Belkin & Niyogi (default: `"nn"`; values: {`"nn"`,
#' `"dist"`, `"heat"`})
#' @param metric discrete; The metric with which to assess 'closeness' for nearest
#' neighbour selection, one of'correlation' (pearson) or 'euclidean'. Default is
#' 'correlation'. (default: `"correlation"`; values: {`"correlation"`,
#' `"euclidean"`, `"cosine"`})
#' @param nn_pct numeric; The percentage of cells to use as tge number of nearest
#' neighbours if kernel == 'nn'. (default: `0`; range: from `-2` to `1`)
#' @param eps numeric; Maximum distance parameter if kernel == 'dist' (default:
#' `0`; range: from `-5` to `5`)
#' @param t numeric; 'time' for heat kernel if kernel == 'heat' (default: `0`;
#' range: from `-5` to `5`)
#' @param symmetrize discrete; How to make the adjacency matrix symmetric. Note
#' that slightlycounterintuitively, node i having node j as a nearest neighbour
#' doesn't guarantee nodej has node i. There are several ways to get round
#' this:\itemize{\item \code{mean} If the above case occurs make the link weight
#' 0.5 so the adjacency matrix becomes \eqn{0.5(A + A')}\item \code{ceil} If the
#' above case occurs set the link weight to 1 (ie take the ceiling of the mean
#' case)\item \code{floor} If the above case occurs set the link weight to 0 (ie
#' take the floor of the mean case)} (default: `"mean"`; values: {`"mean"`,
#' `"ceil"`, `"floor"`})
#' @param measure_type discrete; Type of laplacian eigenmap, which corresponds to
#' the constraint on the eigenvalue problem. Iftype is 'unorm' (default), then the
#' graph measure used is the identity matrix, while if type is 'norm' then the
#' measureused is the degree matrix. (default: `"unorm"`; values: {`"unorm"`,
#' `"norm"`})
#' @param thresh numeric; Convergence threshold on shortest distances to the
#' curve. (default: `0.001`; range: from `1e-05` to `1e+05`)
#' @param maxit integer; Maximum number of iterations. (default: `10L`; range:
#' from `0L` to `50L`)
#' @param stretch numeric; A factor by which the curve can be extrapolated
#' whenpoints are projected.  Default is 2 (times the last segmentlength). The
#' default is 0 for \code{smoother} equal to\code{"periodic_lowess"}. (default:
#' `2`; range: from `0` to `5`)
#' @param smoother discrete; Choice of smoother. The default
#' is\code{"smooth_spline"}, and other choices are \code{"lowess"}
#' and\code{"periodic_lowess"}. The latter allows one to fit closed curves.Beware,
#' you may want to use \code{iter = 0} with \code{lowess()}. (default:
#' `"smooth.spline"`; values: {`"smooth.spline"`, `"lowess"`,
#' `"periodic.lowess"`})
#' @inheritParams dynwrap::create_ti_method_container
#' 
#' @return A TI method wrapper to be used together with
#' \code{\link[dynwrap:infer_trajectories]{infer_trajectory}}
#' @export
ti_embeddr <- function(
    ndim = 2L,
    kernel = "nn",
    metric = "correlation",
    nn_pct = 0,
    eps = 0,
    t = 0,
    symmetrize = "mean",
    measure_type = "unorm",
    thresh = 0.001,
    maxit = 10L,
    stretch = 2,
    smoother = "smooth.spline"
) {
  create_ti_method_container(
    container_id = "dynverse/ti_embeddr",
    version = dynmethods::method_versions[["dynverse/ti_embeddr"]],
  )(
    ndim = ndim,
    kernel = kernel,
    metric = metric,
    nn_pct = nn_pct,
    eps = eps,
    t = t,
    symmetrize = symmetrize,
    measure_type = measure_type,
    thresh = thresh,
    maxit = maxit,
    stretch = stretch,
    smoother = smoother
  )
}

