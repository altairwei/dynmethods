######################################### DO NOT EDIT! #########################################
#### This file is automatically generated from data-raw/2-generate_r_code_from_containers.R ####
################################################################################################

#' @title Inferring a trajectory inference using Sincell
#' 
#' @description
#' Will generate a trajectory using
#' [Sincell](https://doi.org/10.1093/bioinformatics/btv368).
#' 
#' This method was wrapped inside a
#' [container](https://github.com/dynverse/dynmethods/tree/master/containers/sincell).
#' The original code of this method is available
#' [here](https://github.com/Cortalak/MCA_Sincell_0).
#' 
#' @references Juliá, M., Telenti, A., Rausell, A., 2015. Sincell: an
#' R/Bioconductor package for statistical assessment of cell-state hierarchies
#' from single-cell RNA-seq: Fig. 1. Bioinformatics 31, 3380–3382.
#' 
#' @param distance_method discrete; Distance method to be used. The available
#' distances are the Euclidean distance (method="euclidean"), Manhattan distance
#' (also called L1 distance, method="L1"), cosine distance (method="cosine") ,
#' distance based on Pearson (method="pearson") or Spearman (method="spearman")
#' correlation coefficients, and distance based on Mutual Information
#' (method="MI"). Intervals used to assess Mutual Information are indicated in the
#' parameter 'bins'. (default: `"euclidean"`; values: {`"euclidean"`, `"cosine"`,
#' `"pearson"`, `"spearman"`, `"L1"`, `"MI"`})
#' @param dimred_method discrete; Dimensionality reduction algorithm to be used.
#' Options are: Principal Component Analysis (method="PCA"), Independent Component
#' Analysis (method="ICA"; using fastICA() function in fastICA package),
#' t-Distributed Stochastic Neighbor Embedding (method="tSNE"; using Rtsne()
#' function in Rtsne package with parameters tsne.perplexity=1 and
#' tsne.theta=0.25), classical Multidimensional Scaling (method="classical-MDS";
#' using the cmdscale() function) and non-metric Multidimensional Scaling
#' (method="nonmetric-MDS";using the isoMDS() function in MASS package). if
#' method="PCA" is chosen, the proportion of variance explained by each of the
#' principal axes is plotted. We note that Sincell makes use of the Rtsne
#' implementation of the Barnes-Hut algorithm, which approximates the likelihood.
#' The user should be aware that this is a less accurate version of t-SNE than
#' e.g. the one used as basis of viSNE (Amir,E.D. et al. 2013, Nat Biotechnol 31,
#' 545-552). (default: `"none"`; values: {`"none"`, `"PCA"`, `"ICA"`, `"tSNE"`,
#' `"classical-MDS"`, `"nonmetric-MDS"`})
#' @param clust.method discrete; If clust.method="max.distance", clusters are
#' defined as subgraphs generated by a maximum pair-wise distance cut-off, that
#' is: from a totally connected graph where all cells are connected to each other,
#' the algorithm only keeps pairs of cells connected by a distance lower than a
#' given threshold.If clust.method="percent", clusters are defined as subgraphs
#' generated by a given rank-percentile of the shortest pair-wise distances, that
#' is; from a totally connected graph where all cells are connected to each other,
#' the algorithm only keeps the top 'x' percent of shortest pairwise distances as
#' indicated by "shortest.rank.percent".If clust.method="knn", unsupervised
#' K-Nearest Neighbors (K-NN) clustering is performed: From a totally disconnected
#' graph where none of the cells are connected to each other, the algorithm
#' connects each cell to its 'k' nearest neighbors. If parameter "mutual=TRUE",
#' Unsupervised K-Mutual Nearest Neighbours (K-MNN) clustering is performed, that
#' is: only reciprocal k nearest neighbors are connected.If
#' clust.method="k-medoids", clustering around medoids (a more robust version of
#' k-means) is performed with function "pam" from package "cluster" on the
#' distance matrix in mySincellObject$cell2celldist with a desired number of
#' groups indicated in parameter "num.clusters"Hierarchical agglomerative
#' clustering can be performed by internally calling function "hclust" where the
#' agglomeration method is indicated in parameter "clust.method" as one of
#' "ward.D", "ward.D2", "single", "complete", "average" (= UPGMA), "mcquitty" (=
#' WPGMA), "median" (= WPGMC) or "centroid" (= UPGMC). Clusters are obtained by
#' cutting the tree produced by hclust with function cutree with a desired number
#' of groups indicated in parameter "num.clusters" (default: `"max.distance"`;
#' values: {`"max.distance"`, `"percent"`, `"knn"`, `"k-medoids"`, `"ward.D"`,
#' `"ward.D2"`, `"single"`, `"complete"`, `"average"`, `"mcquitty"`, `"median"`,
#' `"centroid"`})
#' @param mutual logical; If clust.method="knn" and "mutual=TRUE", Unsupervised
#' K-Mutual Nearest Neighbours (K-MNN) clustering is performed, that is: only
#' reciprocal k nearest neighbors are connected.
#' @param max.distance numeric; In max.distance algorithm, select up to which
#' distance the points will be linked (default: `0`; range: from `0` to `5`)
#' @param k integer; If clust.method="knn", k is an integer specifying the number
#' of nearest neighbors to consider in K-NN and K-KNN (default: `3L`; range: from
#' `1L` to `99L`)
#' @param shortest.rank.percent numeric; In percent algorithm, select the percent
#' of shortest distances will be represented as links (default: `10`; range: from
#' `0` to `100`)
#' @param graph.algorithm discrete; Graph building algorithm to be used: the
#' Minimum Spanning Tree (graph.algorithm="MST"), the Maximum Similarity Spanning
#' Tree (graph.algorithm="SST") and the Iterative Mutual Clustering Graph
#' (graph.algorithm="IMC"). (default: `"MST"`; values: {`"MST"`, `"SST"`,
#' `"IMC"`})
#' @param graph.using.cells.clustering logical; If
#' graph.using.cells.clustering=TRUE and graph.algorithm="MST" or
#' graph.algorithm="MST", a precalculated clustering of cells is used. The
#' clustering of cells is taken from SincellObject$cellsClustering as calculated
#' by function sc_clusterObj().
#' @param k_imc integer; If IMC algorithm is selected, the number of nearest
#' neighbors used in the underlying K-Mutual Nearest Neighbour (K-MNN) algorithm
#' is set to k. (default: `3L`; range: from `1L` to `99L`)
#' @param pct_leaf_node_cutoff numeric; Leaf nodes are iteratively removed until
#' the percentage of leaf nodes is below the given cutoff. Removed nodes are
#' projected to their closest neighbour. This is to constrain the number of
#' milestones being created. (default: `0.5`; range: from `0.01` to `0.8`)
#' @inheritParams dynwrap::create_ti_method_with_container
#' 
#' @return A TI method wrapper to be used together with
#' \code{\link[dynwrap:infer_trajectories]{infer_trajectory}}
#' @export
ti_sincell <- function(
    distance_method = "euclidean",
    dimred_method = "none",
    clust.method = "max.distance",
    mutual = TRUE,
    max.distance = 0,
    k = 3L,
    shortest.rank.percent = 10,
    graph.algorithm = "MST",
    graph.using.cells.clustering = FALSE,
    k_imc = 3L,
    pct_leaf_node_cutoff = 0.5,
    config = dynwrap::container_config()
) {
  create_ti_method_with_container(
    image = "dynverse/sincell@sha256:5630874aed3ee79112330e48a18e598f14d2813a0c300f1e84ad8107f731098c",
    config = config
  )(
    distance_method = distance_method,
    dimred_method = dimred_method,
    clust.method = clust.method,
    mutual = mutual,
    max.distance = max.distance,
    k = k,
    shortest.rank.percent = shortest.rank.percent,
    graph.algorithm = graph.algorithm,
    graph.using.cells.clustering = graph.using.cells.clustering,
    k_imc = k_imc,
    pct_leaf_node_cutoff = pct_leaf_node_cutoff
  )
}

